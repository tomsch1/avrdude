From d0cf0b20fc37947d3f973f2052c41124f3d3237d Mon Sep 17 00:00:00 2001
From: Alexander Sverdlin <alexander.sverdlin@gmail.com>
Date: Sun, 21 Feb 2021 14:19:41 +0100
Subject: [PATCH 5/6] linuxspi: Support GPIO uAPI v2

Since Linux v5.10 GPIO ABI Version 1 is optional and depends on
CONFIG_GPIO_CDEV_V1.
---
 avrdude/linuxspi.c | 33 +++++++++++++++++++++++++++++++--
 1 file changed, 31 insertions(+), 2 deletions(-)

diff --git a/avrdude/linuxspi.c b/avrdude/linuxspi.c
index da2821f..9f7e2ed 100644
--- a/avrdude/linuxspi.c
+++ b/avrdude/linuxspi.c
@@ -109,6 +109,16 @@ static int linuxspi_reset_mcu(PROGRAMMER *pgm, bool active)
      */
     data.values[0] = active ^ !(pgm->pinno[PIN_AVR_RESET] & PIN_INVERSE);
     ret = ioctl(fd_linehandle, GPIOHANDLE_SET_LINE_VALUES_IOCTL, &data);
+#ifdef GPIO_V2_LINE_SET_VALUES_IOCTL
+    if (ret == -1) {
+        struct gpio_v2_line_values val;
+
+        val.mask = 1;
+        val.bits = active ^ !(pgm->pinno[PIN_AVR_RESET] & PIN_INVERSE);
+
+        ret = ioctl(fd_linehandle, GPIO_V2_LINE_SET_VALUES_IOCTL, &val);
+    }
+#endif
     if (ret == -1) {
         ret = -errno;
         avrdude_message(MSG_INFO, "%s error: Unable to set GPIO line %d value\n",
@@ -169,6 +179,27 @@ static int linuxspi_open(PROGRAMMER *pgm, char *port)
     req.flags = GPIOHANDLE_REQUEST_OUTPUT;
 
     ret = ioctl(fd_gpiochip, GPIO_GET_LINEHANDLE_IOCTL, &req);
+    if (ret != -1)
+        fd_linehandle = req.fd;
+#ifdef GPIO_V2_GET_LINE_IOCTL
+    if (ret == -1) {
+        struct gpio_v2_line_request reqv2;
+
+        memset(&reqv2, 0, sizeof(reqv2));
+        reqv2.offsets[0] = pgm->pinno[PIN_AVR_RESET] & ~PIN_INVERSE;
+        strncpy(reqv2.consumer, progname, sizeof(reqv2.consumer) - 1);
+        reqv2.config.flags = GPIO_V2_LINE_FLAG_OUTPUT;
+        reqv2.config.num_attrs = 1;
+        reqv2.config.attrs[0].attr.id = GPIO_V2_LINE_ATTR_ID_OUTPUT_VALUES;
+        reqv2.config.attrs[0].attr.values = !!(pgm->pinno[PIN_AVR_RESET] & PIN_INVERSE);
+        reqv2.config.attrs[0].mask = 1;
+        reqv2.num_lines = 1;
+
+        ret = ioctl(fd_gpiochip, GPIO_V2_GET_LINE_IOCTL, &reqv2);
+        if (ret != -1)
+            fd_linehandle = reqv2.fd;
+    }
+#endif
     if (ret == -1) {
         ret = -errno;
         avrdude_message(MSG_INFO, "%s error: Unable to get GPIO line %d\n",
@@ -176,8 +207,6 @@ static int linuxspi_open(PROGRAMMER *pgm, char *port)
         goto close_gpiochip;
     }
 
-    fd_linehandle = req.fd;
-
     ret = linuxspi_reset_mcu(pgm, true);
     if (ret)
         goto close_out;
-- 
2.29.2

